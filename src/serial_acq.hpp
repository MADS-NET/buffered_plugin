/*
  ____            _       _                     
 / ___|  ___ _ __(_) __ _| |   __ _  ___ __ _   
 \___ \ / _ \ '__| |/ _` | |  / _` |/ __/ _` |  
  ___) |  __/ |  | | (_| | | | (_| | (_| (_| |_ 
 |____/ \___|_|  |_|\__,_|_|  \__,_|\___\__, (_)
                                           |_|  
Serial port acquisitor
NOTE: This example expects data generated by the arduino sketch available on
https://github.com/MADS-NET/arduino_plugin/tree/main/arduino/mads
*/

#pragma once

#include <serial/serial.h>
#include "acquisitor.hpp"

// Inherit the base class and SPECIALIZE ITS TEMPLATE PARAMETER
// This is any container that collects all the data in a single
// reading. A std::array<double, size> is usually efficient to 
// read a sample made of `size` doubles.
// If you are reading a triaxial accel, for example, array<double, 3> is OK
class SerialportAcquisitor : public Acquisitor<array<double, 3>> {
public:

  // Constructor must be defined and it must call base class constructor
  SerialportAcquisitor(json j, size_t capa = 0) : Acquisitor(j, capa) {
    setup();
  }

  // Only implement if you need cleanup
  ~SerialportAcquisitor() {
    if (_serial.get() != nullptr)
      _serial->close();
  }

  // Override this to prepare connection and devices
  void setup() override {
    if (_serial.get() && _serial->isOpen()) return;
    _port = _settings.value("port", "");
    _baud = _settings.value("baud", 115200);
    _timeout = serial::Timeout::simpleTimeout(_settings.value("timeout", 100));
    _serial = make_unique<serial::Serial>(_port, _baud, _timeout);
    if (!_serial->isOpen()) {
      _serial->open();
    }
  }

  // Single acquisition: this must be overridden. In particular, you have to
  // create a new Acquisitor::sample struct with current time and
  // with a new instance of the class template parameter (here array<double 3>))
  void acquire() override {
    if (is_full()) throw AcquisitorException();
    string line = _serial->readline();
    json j;
    try {
      j = json::parse(line);
    } catch (exception &e) {
      cerr << "Cannot parse JSON: " << e.what();
    }

    // Careful with this: here we expect a JSON string with fields nested
    // into ["data"]
    Acquisitor::sample s{
      system_clock::now(),
      {j["data"].value("AI1", 0.0), j["data"].value("AI2", 0.0), j["data"].value("AI3", 0.0)}
    };
    _data.push_back(s);
  }

private:
  string _port;
  size_t _baud;
  unique_ptr<serial::Serial> _serial;
  serial::Timeout _timeout;
};